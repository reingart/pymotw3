# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Doug Hellmann
# This file is distributed under the same license as the PyMOTW-3 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyMOTW-3 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-03-24 18:41-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../source/readline/index.rst:3
msgid "readline --- The GNU readline Library"
msgstr ""

#: ../../source/readline/index.rst:8
msgid ""
"Provides an interface to the GNU readline library for interacting with "
"the user at a command prompt."
msgstr ""

#: ../../source/readline/index.rst:11
msgid ""
"The ``readline`` module can be used to enhance interactive command line "
"programs to make them easier to use.  It is primarily used to provide "
"command line text completion, or \"tab completion\"."
msgstr ""

#: ../../source/readline/index.rst:17
msgid ""
"Because ``readline`` interacts with the console content, printing debug "
"messages makes it difficult to see what it happening in the sample code "
"versus what readline is doing for free.  The following examples use the "
":mod:`logging` module to write debug information to a separate file.  The"
" log output is shown with each example."
msgstr ""

#: ../../source/readline/index.rst:26
msgid ""
"The GNU libraries needed for ``readline`` are not available on all "
"platforms by default.  If your system does not include them, you may need"
" to recompile the Python interpreter to enable the module, after "
"installing the dependencies. A stand-alone version of the library is also"
" distributed from the Python Package Index under the name gnureadline_. "
"The examples in this section first try to import gnureadline, and then "
"fall back to readline."
msgstr ""

#: ../../source/readline/index.rst:39
msgid "Configuring"
msgstr ""

#: ../../source/readline/index.rst:41
msgid ""
"There are two ways to configure the underlying readline library, using a "
"configuration file or the ``parse_and_bind()`` function. Configuration "
"options include the key-binding to invoke completion, editing modes "
"(``vi`` or ``emacs``), and many other values.  Refer to the documentation"
" for the GNU readline library for details."
msgstr ""

#: ../../source/readline/index.rst:48
msgid ""
"The easiest way to enable tab-completion is through a call to "
"``parse_and_bind()``.  Other options can be set at the same time. This "
"example changes the editing controls to use \"vi\" mode instead of the "
"default of \"emacs\".  To edit the current input line, press ``ESC`` then"
" use normal ``vi`` navigation keys such as ``j``, ``k``, ``l``, and "
"``h``."
msgstr ""

#: ../../source/readline/index.rst
msgid "readline_parse_and_bind.py"
msgstr ""

#: ../../source/readline/index.rst:59
msgid ""
"The same configuration can be stored as instructions in a file read by "
"the library with a single call.  If ``myreadline.rc`` contains"
msgstr ""

#: ../../source/readline/index.rst
msgid "myreadline.rc"
msgstr ""

#: ../../source/readline/index.rst:65
msgid "the file can be read with ``read_init_file()``"
msgstr ""

#: ../../source/readline/index.rst
msgid "readline_read_init_file.py"
msgstr ""

#: ../../source/readline/index.rst:72
msgid "Completing Text"
msgstr ""

#: ../../source/readline/index.rst:74
msgid ""
"This program has a built-in set of possible commands and uses tab-"
"completion when the user is entering instructions."
msgstr ""

#: ../../source/readline/index.rst
msgid "readline_completer.py"
msgstr ""

#: ../../source/readline/index.rst:81
msgid ""
"The ``input_loop()`` function reads one line after another until the "
"input value is ``\"stop\"``.  A more sophisticated program could actually"
" parse the input line and run the command."
msgstr ""

#: ../../source/readline/index.rst:85
msgid ""
"The ``SimpleCompleter`` class keeps a list of \"options\" that are "
"candidates for auto-completion.  The ``complete()`` method for an "
"instance is designed to be registered with ``readline`` as the source of "
"completions.  The arguments are a ``text`` string to complete and a "
"``state`` value, indicating how many times the function has been called "
"with the same text.  The function is called repeatedly with the state "
"incremented each time.  It should return a string if there is a candidate"
" for that state value or ``None`` if there are no more candidates.  The "
"implementation of ``complete()`` here looks for a set of matches when "
"state is ``0``, and then returns all of the candidate matches one at a "
"time on subsequent calls."
msgstr ""

#: ../../source/readline/index.rst:97
msgid "When run, the initial output is:"
msgstr ""

#: ../../source/readline/index.rst:105
msgid "Pressing ``TAB`` twice causes a list of options to be printed."
msgstr ""

#: ../../source/readline/index.rst:115
msgid ""
"The log file shows that ``complete()`` was called with two separate "
"sequences of state values."
msgstr ""

#: ../../source/readline/index.rst:135
msgid ""
"The first sequence is from the first TAB key-press.  The completion "
"algorithm asks for all candidates but does not expand the empty input "
"line.  Then on the second TAB, the list of candidates is recalculated so "
"it can be printed for the user."
msgstr ""

#: ../../source/readline/index.rst:140
msgid "If the next input is \"``l``\" followed by another TAB, the screen shows:"
msgstr ""

#: ../../source/readline/index.rst:147
msgid "and the log reflects the different arguments to ``complete()``:"
msgstr ""

#: ../../source/readline/index.rst:155
msgid ""
"Pressing RETURN now causes ``input()`` to return the value, and the "
"``while`` loop cycles."
msgstr ""

#: ../../source/readline/index.rst:163
msgid ""
"There are two possible completions for a command beginning with "
"\"``s``\".  Typing \"``s``\", then pressing TAB finds that \"``start``\" "
"and \"``stop``\" are candidates, but only partially completes the text on"
" the screen by adding a \"``t``\"."
msgstr ""

#: ../../source/readline/index.rst:168
msgid "The log file shows:"
msgstr ""

#: ../../source/readline/index.rst:177
msgid "and the screen:"
msgstr ""

#: ../../source/readline/index.rst:186
msgid ""
"If a completer function raises an exception, it is ignored silently and "
"``readline`` assumes there are no matching completions."
msgstr ""

#: ../../source/readline/index.rst:192
msgid "Accessing the Completion Buffer"
msgstr ""

#: ../../source/readline/index.rst:194
msgid ""
"The completion algorithm in ``SimpleCompleter`` only looks at the text "
"argument passed to the function, but does not use any more of readline's "
"internal state.  It is also possible to use ``readline`` functions to "
"manipulate the text of the input buffer."
msgstr ""

#: ../../source/readline/index.rst
msgid "readline_buffer.py"
msgstr ""

#: ../../source/readline/index.rst:203
msgid ""
"In this example, commands with sub-options are being completed. The "
"``complete()`` method needs to look at the position of the completion "
"within the input buffer to determine whether it is part of the first word"
" or a later word.  If the target is the first word, the keys of the "
"options dictionary are used as candidates.  If it is not the first word, "
"then the first word is used to find candidates from the options "
"dictionary."
msgstr ""

#: ../../source/readline/index.rst:211
msgid "There are three top-level commands, two of which have sub-commands."
msgstr ""

#: ../../source/readline/index.rst:213
msgid "list"
msgstr ""

#: ../../source/readline/index.rst:215
msgid "files"
msgstr ""

#: ../../source/readline/index.rst:216
msgid "directories"
msgstr ""

#: ../../source/readline/index.rst:218
msgid "print"
msgstr ""

#: ../../source/readline/index.rst:220
msgid "byname"
msgstr ""

#: ../../source/readline/index.rst:221
msgid "bysize"
msgstr ""

#: ../../source/readline/index.rst:223
msgid "stop"
msgstr ""

#: ../../source/readline/index.rst:226
msgid ""
"Following the same sequence of actions as before, pressing TAB twice "
"gives the three top-level commands:"
msgstr ""

#: ../../source/readline/index.rst:237
msgid "and in the log:"
msgstr ""

#: ../../source/readline/index.rst:260
msgid ""
"If the first word is ``\"list \"`` (with a space after the word), the "
"candidates for completion are different."
msgstr ""

#: ../../source/readline/index.rst:268
msgid ""
"The log shows that the text being completed is *not* the full line, but "
"the portion after ``list``."
msgstr ""

#: ../../source/readline/index.rst:293
msgid "Input History"
msgstr ""

#: ../../source/readline/index.rst:295
msgid ""
"``readline`` tracks the input history automatically.  There are two "
"different sets of functions for working with the history.  The history "
"for the current session can be accessed with "
"``get_current_history_length()`` and ``get_history_item()``.  That same "
"history can be saved to a file to be reloaded later using "
"``write_history_file()`` and ``read_history_file()``.  By default the "
"entire history is saved but the maximum length of the file can be set "
"with ``set_history_length()``.  A length of -1 means no limit."
msgstr ""

#: ../../source/readline/index.rst
msgid "readline_history.py"
msgstr ""

#: ../../source/readline/index.rst:308
msgid ""
"The ``HistoryCompleter`` remembers everything typed, and uses those "
"values when completing subsequent inputs."
msgstr ""

#: ../../source/readline/index.rst:329
msgid "The log shows this output when the \"``b``\" is followed by two TABs."
msgstr ""

#: ../../source/readline/index.rst:344
msgid ""
"When the script is run the second time, all of the history is read from "
"the file."
msgstr ""

#: ../../source/readline/index.rst:355
msgid ""
"There are functions for removing individual history items and clearing "
"the entire history, as well."
msgstr ""

#: ../../source/readline/index.rst:359
msgid "Hooks"
msgstr ""

#: ../../source/readline/index.rst:361
msgid ""
"There are several hooks available for triggering actions as part of the "
"interaction sequence.  The *startup* hook is invoked immediately before "
"printing the prompt, and the *pre-input* hook is run after the prompt, "
"but before reading text from the user."
msgstr ""

#: ../../source/readline/index.rst
msgid "readline_hooks.py"
msgstr ""

#: ../../source/readline/index.rst:370
msgid ""
"Either hook is a potentially good place to use ``insert_text()`` to "
"modify the input buffer."
msgstr ""

#: ../../source/readline/index.rst:379
msgid ""
"If the buffer is modified inside the pre-input hook, ``redisplay()`` must"
" be called to update the screen."
msgstr ""

#: ../../source/readline/index.rst:384
msgid ":pydoc:`readline`"
msgstr ""

#: ../../source/readline/index.rst:386
msgid ""
"`GNU readline <http://tiswww.case.edu/php/chet/readline/readline.html>`_ "
"-- Documentation for the GNU readline library."
msgstr ""

#: ../../source/readline/index.rst:390
msgid ""
"`readline init file format "
"<http://tiswww.case.edu/php/chet/readline/readline.html#SEC10>`_ -- The "
"initialization and configuration file format."
msgstr ""

#: ../../source/readline/index.rst:394
msgid ""
"`effbot: The readline module "
"<http://sandbox.effbot.org/librarybook/readline.htm>`_ -- Effbot's guide "
"to the readline module."
msgstr ""

#: ../../source/readline/index.rst:398
msgid ""
"gnureadline_ -- A statically linked version of ``readline`` available for"
" many platforms and installable via ``pip``."
msgstr ""

#: ../../source/readline/index.rst:401
msgid ""
"`pyreadline <http://ipython.org/pyreadline.html>`_ -- pyreadline, "
"developed as a Python-based replacement for readline to be used on "
"Windows."
msgstr ""

#: ../../source/readline/index.rst:405
msgid ""
":mod:`cmd` -- The ``cmd`` module uses ``readline`` extensively to "
"implement tab-completion in the command interface.  Some of the examples "
"here were adapted from the code in ``cmd``."
msgstr ""

#: ../../source/readline/index.rst:409
msgid ""
":mod:`rlcompleter` -- ``rlcompleter`` uses ``readline`` to add tab-"
"completion to the interactive Python interpreter."
msgstr ""

