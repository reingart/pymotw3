# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Doug Hellmann
# This file is distributed under the same license as the PyMOTW-3 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyMOTW-3 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-03-24 18:41-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../source/hmac/index.rst:3
msgid "hmac --- Cryptographic Message Signing and Verification"
msgstr ""

#: ../../source/hmac/index.rst:9
msgid ""
"The hmac module implements keyed-hashing for message authentication, as "
"described in RFC 2104."
msgstr ""

#: ../../source/hmac/index.rst:12
msgid ""
"The HMAC algorithm can be used to verify the integrity of information "
"passed between applications or stored in a potentially vulnerable "
"location. The basic idea is to generate a cryptographic hash of the "
"actual data combined with a shared secret key. The resulting hash can "
"then be used to check the transmitted or stored message to determine a "
"level of trust, without transmitting the secret key."
msgstr ""

#: ../../source/hmac/index.rst:21
msgid ""
"Disclaimer: I am not a security expert. For the full details on HMAC, "
"check out :rfc:`2104`."
msgstr ""

#: ../../source/hmac/index.rst:25
msgid "Signing Messages"
msgstr ""

#: ../../source/hmac/index.rst:27
msgid ""
"The ``new()`` function creates a new object for calculating a message "
"signature.  This example uses the default MD5 hash algorithm."
msgstr ""

#: ../../source/hmac/index.rst
msgid "hmac_simple.py"
msgstr ""

#: ../../source/hmac/index.rst:34
msgid ""
"When run, the code reads a data file and computes an HMAC signature for "
"it."
msgstr ""

#: ../../source/hmac/index.rst:50
msgid "Alternate Digest Types"
msgstr ""

#: ../../source/hmac/index.rst:52
msgid ""
"Although the default cryptographic algorithm for ``hmac`` is MD5, that is"
" not the most secure method to use. MD5 hashes have some weaknesses, such"
" as collisions (where two different messages produce the same hash). The "
"SHA-1 algorithm is considered to be stronger, and should be used instead."
msgstr ""

#: ../../source/hmac/index.rst
msgid "hmac_sha.py"
msgstr ""

#: ../../source/hmac/index.rst:62
msgid ""
"The ``new()`` function takes three arguments. The first is the secret "
"key, which should be shared between the two endpoints that are "
"communicating so both ends can use the same value. The second value is an"
" initial message. If the message content that needs to be authenticated "
"is small, such as a timestamp or HTTP POST, the entire body of the "
"message can be passed to ``new()`` instead of using the ``update()`` "
"method. The last argument is the digest module to be used. The default is"
" ``hashlib.md5``. This example passes ``'sha1'``, causing ``hmac`` to use"
" ``hashlib.sha1``"
msgstr ""

#: ../../source/hmac/index.rst:85
msgid "Binary Digests"
msgstr ""

#: ../../source/hmac/index.rst:87
msgid ""
"The previous examples used the ``hexdigest()`` method to produce "
"printable digests. The hexdigest is a different representation of the "
"value calculated by the ``digest()`` method, which is a binary value that"
" may include unprintable characters, including ``NUL``.  Some web "
"services (Google checkout, Amazon S3) use the base64 encoded version of "
"the binary digest instead of the hexdigest."
msgstr ""

#: ../../source/hmac/index.rst
msgid "hmac_base64.py"
msgstr ""

#: ../../source/hmac/index.rst:98
msgid ""
"The base64 encoded string ends in a newline, which frequently needs to be"
" stripped off when embedding the string in http headers or other "
"formatting-sensitive contexts."
msgstr ""

#: ../../source/hmac/index.rst:117
msgid "Applications of Message Signatures"
msgstr ""

#: ../../source/hmac/index.rst:119
msgid ""
"HMAC authentication should be used for any public network service, and "
"any time data is stored where security is important. For example, when "
"sending data through a pipe or socket, that data should be signed and "
"then the signature should be tested before the data is used. The extended"
" example given here is available in the file ``hmac_pickle.py``."
msgstr ""

#: ../../source/hmac/index.rst:126
msgid ""
"The first step is to establish a function to calculate a digest for a "
"string, and a simple class to be instantiated and passed through a "
"communication channel."
msgstr ""

#: ../../source/hmac/index.rst
msgid "hmac_pickle.py"
msgstr ""

#: ../../source/hmac/index.rst:134
msgid ""
"Next, create a :mod:`BytesIO` buffer to represent the socket or pipe. The"
" example uses a naive, but easy to parse, format for the data stream. The"
" digest and length of the data are written, followed by a new line. The "
"serialized representation of the object, generated by :mod:`pickle`, "
"follows. A real system would not want to depend on a length value, since "
"if the digest is wrong the length is probably wrong as well. Some sort of"
" terminator sequence not likely to appear in the real data would be more "
"appropriate."
msgstr ""

#: ../../source/hmac/index.rst:143
msgid ""
"The example program then writes two objects to the stream. the first is "
"written using the correct digest value."
msgstr ""

#: ../../source/hmac/index.rst:149
msgid ""
"The second object is written to the stream with an invalid digest, "
"produced by calculating the digest for some other data instead of the "
"pickle."
msgstr ""

#: ../../source/hmac/index.rst:156
msgid ""
"Now that the data is in the :mod:`BytesIO` buffer, it can be read back "
"out again.  Start by reading the line of data with the digest and data "
"length.  Then read the remaining data, using the length value. "
"``pickle.load()`` could read directly from the stream, but that assumes a"
" trusted data stream and this data is not yet trusted enough to unpickle "
"it. Reading the pickle as a string from the stream, without actually "
"unpickling the object, is safer."
msgstr ""

#: ../../source/hmac/index.rst:167
msgid ""
"Once the pickled data is in memory, the digest value can be recalculated "
"and compared against the data read using ``compare_digest()``. If the "
"digests match, it is safe to trust the data and unpickle it."
msgstr ""

#: ../../source/hmac/index.rst:175
msgid ""
"The output shows that the first object is verified and the second is "
"deemed \"corrupted\", as expected."
msgstr ""

#: ../../source/hmac/index.rst:200
msgid ""
"Comparing two digests with a simple string or bytes comparison can be "
"used in a timing attack to expose part or all of the secret key by "
"passing digests of different lengths. ``compare_digest()`` implements a "
"fast but constant-time comparison function to protect against timing "
"attacks."
msgstr ""

#: ../../source/hmac/index.rst:208
msgid ":pydoc:`hmac`"
msgstr ""

#: ../../source/hmac/index.rst:210
msgid ":rfc:`2104` -- HMAC: Keyed-Hashing for Message Authentication"
msgstr ""

#: ../../source/hmac/index.rst:212
msgid ""
":mod:`hashlib` -- The ``hashlib`` module provides MD5 and SHA1 hash "
"generators."
msgstr ""

#: ../../source/hmac/index.rst:215
msgid ":mod:`pickle` -- Serialization library."
msgstr ""

#: ../../source/hmac/index.rst:217
msgid ""
"`WikiPedia: MD5 <https://en.wikipedia.org/wiki/MD5>`_ -- Description of "
"the MD5 hashing algorithm."
msgstr ""

#: ../../source/hmac/index.rst:220
msgid ""
"`Signing and Authenticating REST Requests (Amazon AWS) "
"<http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html>`__"
" -- Instructions for authenticating to S3 using HMAC-SHA1 signed "
"credentials."
msgstr ""

